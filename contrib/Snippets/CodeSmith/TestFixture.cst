<%@ CodeTemplate Language="C#" TargetLanguage="C#" Description="Assert Tester Wrapper" Debug="True"%>
<%@ Property Name="Class" Type="System.String" Category="Options" Description="Prefix of the class name, Assert will be appended." %>
<%@ Property Name="Namespace" Type="System.String" Category="Options" Description="Namespace of the wrapped class" %>
<%@ Property Name="TestNamespace" Type="System.String" Category="Options" Description="Namespace of the generated test" Optional="False" %>
<%@ Property Name="AsTypeFixture" Type="System.Boolean" Category="Options" Description="Generate as Type fixture" %>
<%@ Property Name="TestConstructors" Type="System.Boolean" Category="Options" Description="Generate tests for constructors" Default="True" %>
<%@ Property Name="TestAllProperties" Type="System.Boolean" Category="Options" Description="Generate tests for constructors" Default="True" %>
<%@ Property Name="TestAllMethods" Type="System.Boolean" Category="Options" Description="Generate tests for constructors" Default="True" %>
<%@ Property Name="TestMethodsDeep" Type="System.Boolean" Category="Options" Description="Generate tests for constructors" Default="True" %>
<%@ Assembly Name="AssemblyHelper"%>
<%@ Assembly Name="ILReader"%>
<%@ Assembly Name="QuickGraph.Applications"%>
<%@ Assembly Name="QuickGraph"%>
<%@ Assembly Name="QuickGraph.Concepts"%>
<%@ Assembly Name="QuickGraph.Collections"%>
<%@ Import Namespace="System.Reflection" %>
<%@ Import Namespace="System.Reflection.Emit" %>
<%@ Import Namespace="System.Collections" %>
<%@ Import Namespace="System.IO" %>
<%@ Import Namespace="System.Text.RegularExpressions" %>
<%@ Import Namespace="AssemblyHelper" %>
<%@ Import Namespace="Reflector.Disassembler"%>

using System;
using MbUnit.Core.Framework;
using MbUnit.Framework;

using <%= Namespace %>;

namespace <%= TestNamespace %>
{
	/// <summary>
	/// Unit test fixture for the <%=SeeClass %> 
	/// </summary>
	/// <remarks>
	/// <para>
	/// This class was originially generated by a template. 
	/// When created, it contains Ignored empty test only. This is just a tool, don't expect intelligent
	/// testing here.
	/// </para>
	/// </remarks>
<% if (AsTypeFixture){%>
	[TypeFixture(typeof(<%= Class %>))]
<%}else{%>
	[TestFixture]
<%}%>
	public class <%= Fixture %>
	{
<% if (!AsTypeFixture) { %>
		#region private members
		private <%= Class %> instance = null;
		#endregion
		
		#region Set up and tear down
		/// <summary>
		/// Sets the <see cref="instance"/> instance.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Allocates an <%= SeeClass %> instance to be used in the tests.
		/// </para>
		/// <para>
		/// Not implemented.
		/// </para>		
		/// </remarks>
		[SetUp]
		public void SetUp()
		{
			throw new NotImplementedException();
		}

		/// <summary>
		/// Releases the resources allocated for the fixture.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Make this method release resource allocated for/during the test.
		/// </para>
		<%if (ClassType is IDisposable){%>
		/// <para>
		/// Disposes the instance method.
		/// </para>
		<%}%>
		/// <para>
		/// Not implemented.
		/// </para>
		/// </remarks>
		[TearDown]
		public void TearDown()
		{
			<%if (ClassType is IDisposable){%>
			if (this.instance!=null)
			{
				this.instance.Dispose();
				this.instance=null;
			}
			<%}%>
			throw new NotImplementedException();
		}
		#endregion
<% if (TestConstructors) {%>
		#region Constructors
<% foreach(ConstructorInfo ci in this.ClassType.GetConstructors()){%>
		/// <summary>
		/// Tests the constructor that takes following arguments: 
		/// <%= ParameterToComment(ci.GetParameters()) %>
		/// </summary>
		[Test]
		[Ignore("Needs implementation")]
		public void <%= ConstructorSignature(ci) %>()
		{
			throw new NotImplementedException();
		}
<%}%>
		#endregion
<%}%>

<%}%>	
		#region Testing properties
<% 	if (this.TestAllProperties){
	foreach(PropertyInfo pi in this.ClassType.GetProperties()) 
	{
	if (pi.CanRead)
	{%>
		/// <summary>
		/// Verifies that the <see cref="<%= pi.Name%>"/> property can be get.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Tries to retreives the value of the property.
		/// </para>
		/// <para>
		/// Not implemented.
		/// </para>
		/// </remarks>
<% AddArgsComment(); %>
		[Test("Tests the <%= pi.Name %> can be read")]
		[Ignore("Needs implementation")]
		public void Get<%= pi.Name %>Test(<%= Args %>)
		{
			<%= pi.PropertyType %> value = <%= Instance%>.<%= pi.Name %>;
		    throw new NotImplementedException();
		}
		
	<%}
	if (pi.CanWrite)
	{%>
		/// <summary>
		/// Verifies that the <see cref="<%= pi.Name%>"/> property can be set.
		/// </summary>
		/// <remarks>
		/// <para>
		/// Not implemented.
		/// </para>
		/// </remarks>
<% AddArgsComment(); %>
		[Test("Tests the <%= pi.Name %> can be written")]
		[Ignore("Needs implementation")]
		public void Set<%= pi.Name %>Test(<%= Args %>)
		{
			<%= pi.PropertyType %> value;
			<%= Instance %>.<%= pi.Name %> = value;
		    throw new NotImplementedException();
		}
		
	<%}%>	
<%}}%>		
		#endregion

		#region Method tests
<% if(this.TestAllMethods){
foreach(MethodInfo mi in this.ClassType.GetMethods()) 
{
	if (mi.Name.StartsWith("get_") || mi.Name.StartsWith("set_"))
		continue;%>
		/// <summary>
		/// Tests the <see cref="<%= mi.Name %>"/> method
		/// </summary>
		/// <remarks>
		/// <para>
		/// Not implemented
		/// </para>
		/// </remarks>
<% AddArgsComment(); %>
		[Test]
		[Ignore("Needs implementation")]
		public void <%= Beautify(mi.Name) %>(<%= Args%>)
		{
			throw new NotImplementedException();
		}
	
<%}}%>
<%if (this.TestMethodsDeep){
	ModuleReader reader = new ModuleReader(this.ClassType.Module, new AssemblyProvider());
	foreach (MethodInfo mi in this.ClassType.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance | BindingFlags.DeclaredOnly))
	{
		MethodBody methodBody = reader.GetMethodBody(mi);
		int index = -1;
		
		foreach(ICollection path in IlGrapher.IlGraphBuilder.GetAllEdgesPath(mi))
		{
			index++;
%>		
		/// <summary>
		/// Tests that the <see cref="<%= mi.Name %>"/> method throws (see remarks)
		/// </summary>
		/// <remarks>
		/// <para>
		/// Not implemented
		/// </para>
<% RenderPathToCode(methodBody, path); %>
		/// </remarks>
<% AddArgsComment(); %>
		[Test]
		[Ignore("Needs implementation")]
		public void <%= Beautify(mi.Name) %><%= index %>(<%= Args%>)
		{
			// don't forget to update the exception type.
			throw new NotImplementedException();
		}			
<%		}
	}		
}%>
		#endregion
	}
}

<script runat="template">
private Assembly assembly;

[Editor(typeof(AssemblyHelper.AssemblyFilePicker), typeof(System.Drawing.Design.UITypeEditor))]
public Assembly AssemblyToLoad
{
      get{return assembly;}
      set{assembly = value;}
}

protected string Args
{
	get
	{
		if (this.AsTypeFixture)
			return String.Format("{0} instance",this.Class);
		else
			return null;
	}
}

protected string Instance
{
	get
	{
		if (this.AsTypeFixture)
			return "instance";
		else
			return "this.instance";
	}
}

protected string SeeClass
{
	get
	{
		return String.Format("<see cref=\"{0}\"/>",this.Class);
	}
}

protected string Fixture
{
	get
	{
		return String.Format("{0}Test",this.Class);
	}
}
protected Type ClassType
{
	get
	{
		return this.AssemblyToLoad.GetType(String.Format("{0}.{1}",this.Namespace, this.Class), true);
	}
}
protected void AddArgsComment()
{
	if (!AsTypeFixture)
		return;
	Response.WriteLine("        /// <param ref=\"instance\">");
	Response.WriteLine("        /// Tested {0} instance.", this.SeeClass);
	Response.WriteLine("        /// </param>");
}

protected string ParameterToComment(ParameterInfo[] pis)
{
	StringWriter sw = new StringWriter();
	sw.Write("<code>");
	bool comma = false;
	foreach(ParameterInfo pi in pis)
	{
		if (comma)
			sw.Write(',');
		comma=true;
		sw.Write("{0} {1}",pi.ParameterType.Name, pi.Name);
	}
	sw.Write("</code>");
	return sw.ToString();
}
protected string ParameterToCode(ParameterInfo[] pis)
{
	StringWriter sw = new StringWriter();
	foreach(ParameterInfo pi in pis)
	{
		sw.Write(TypeToString(pi.ParameterType.Name));
	}
	return sw.ToString();
}
protected string  ConstructorSignature(ConstructorInfo ci)
{
	return String.Format("Constructor{0}",ParameterToCode(ci.GetParameters()));
}
protected string TypeToString(string name)
{
	name = name.Replace('*','P');
	name = name.Replace('[','A');
	name = name.Replace(']','r');
	return name;
}
protected void RenderPathToCode(MethodBody body, ICollection path)
{
	Hashtable ht = new Hashtable();
	foreach(IlGrapher.InstructionVertex ii in path)	
		ht[ii.Instruction.Offset]=null;
		
	Response.WriteLine("        /// <code>"); 
	foreach(Instruction ii in body.GetInstructions())
	{
		if (ht.Contains(ii.Offset))
			Response.WriteLine("        /// [[{0}]]",Render(ii));
		else
			Response.WriteLine("        /// {0}",Render(ii));
	}
	Response.WriteLine("        /// </code>"); 
}

public class AssemblyNotLoadedException : Exception
{}
public class TypeNotFoundException : Exception
{}
public class MethodNotFoundException : Exception
{}
protected string Beautify(string name)
{
	if (name.StartsWith("get_"))
		return "Get" + name.Substring(4, name.Length-4);
	else if (name.StartsWith("set_"))
		return "Set" + name.Substring(4, name.Length-4);
	else
		return name;
}

		public string Render(Instruction ii)
		{
				StringWriter sw =new StringWriter();
				OpCode code = ii.Code;
				object operand = ii.Operand;
				byte[] operandData = ii.GetOperandData();

				sw.Write("L_" + ii.Offset.ToString("x4") + ": ");
				sw.Write(code.Name);
				sw.Write(" ");
			
				if (operand != null)
				{
					switch (code.OperandType)
					{
						case OperandType.InlineNone:
							break;

						case OperandType.ShortInlineBrTarget:
						case OperandType.InlineBrTarget:
							int target = (int) operand;
							sw.Write("L_" + target.ToString("x4"));
							break;

						case OperandType.ShortInlineI:
						case OperandType.InlineI:
						case OperandType.InlineI8:
						case OperandType.ShortInlineR:
						case OperandType.InlineR:
							sw.Write(operand.ToString());
							break;

						case OperandType.InlineString:
							sw.Write("'" + operand.ToString() + "'");
							break;

						case OperandType.ShortInlineVar:
						case OperandType.InlineVar:
							if (operand is int)
								sw.Write("V_" + operand.ToString());
							else if (operand is ParameterInfo)
							{
								ParameterInfo parameterInfo = (ParameterInfo) operand;
								sw.Write((parameterInfo.Name != null) ? parameterInfo.Name : ("A_" + parameterInfo.Position));
							}
							break;

						case OperandType.InlineSwitch:
							sw.Write("(");
							int[] targets = (int[]) operand;
							for (int i = 0; i < targets.Length; i++)
							{
								if (i != 0) sw.Write(", ");
								sw.Write("L_" + targets[i].ToString("x4"));  
							}
							sw.Write(")");
							break;

						case OperandType.InlineSig:
						case OperandType.InlineMethod:
						case OperandType.InlineField:
						case OperandType.InlineType:
						case OperandType.InlineTok:
							if (operand is Type)
							{
								sw.Write((Type) operand);
							}
							else if (operand is MemberInfo)
							{
								MemberInfo memberInfo = (MemberInfo) operand;
								if (memberInfo.DeclaringType != null)
								{
									sw.Write(memberInfo.DeclaringType);
									sw.Write("::");
								}
								sw.Write(memberInfo);
							}
							else
							{
								throw new Exception();
							}
							break;
					}
				}
				else
				{
					if (operandData != null)
					{
						sw.Write("null");
						sw.Write(" // " + code.OperandType + " ");
						foreach (byte b in operandData) 
							sw.Write(b.ToString("X2") + " ");
					}
				}      	
				
				return sw.ToString();
		}
		
private sealed class AssemblyProvider : IAssemblyProvider
{
	public Assembly Load(string assemblyName)
	{
		return Assembly.Load(assemblyName);	
	}
			
	public Assembly[] GetAssemblies()
	{
		throw new NotImplementedException();	
	}
}
</script>